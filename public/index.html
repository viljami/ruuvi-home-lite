<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#1a1a1a" />
    <title>Ruuvi Home</title>
    <link rel="manifest" href="manifest.json" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="apple-touch-icon" href="favicon.svg" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #1a1a1a;
        color: #e0e0e0;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        overflow: hidden;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }
      .header {
        padding: 10px 20px;
        border-bottom: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #222;
        z-index: 1;
      }
      .controls {
        display: flex;
        gap: 10px;
      }
      .btn {
        background: #333;
        border: 1px solid #555;
        color: #e0e0e0;
        padding: 5px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }
      .btn.active {
        background: #4a9eff;
        border-color: #4a9eff;
      }
      .main-content {
        flex: 1;
        display: flex;
      }
      .chart-container {
        flex: 1;
        position: relative;
        padding: 20px;
      }
      .sidebar {
        width: 280px;
        background: #2a2a2a;
        border-left: 1px solid #444;
        padding: 15px;
        overflow-y: auto;
      }
      #chart {
        width: 100%;
        height: 100%;
        display: block;
      }
      .sidebar h3 {
        margin: 0 0 10px 0;
        color: #e0e0e0;
        font-size: 16px;
      }
      .sensor-item {
        background: #333;
        margin-bottom: 6px;
        padding: 8px 10px;
        border-radius: 4px;
        border-left: 3px solid #4a9eff;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .sensor-item:hover {
        background: #404040;
        transform: translateX(2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
      .sensor-left {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .sensor-mac {
        font-family: monospace;
        color: #888;
        font-size: 11px;
      }
      .sensor-temp {
        font-weight: bold;
        color: #4a9eff;
      }
      .sensor-humidity {
        color: #ff6b6b;
      }
      .sensor-age {
        color: #666;
        font-size: 10px;
      }
      .sensor-offline {
        border-left-color: #666;
        opacity: 0.6;
      }
      .sensor-offline .sensor-temp {
        color: #666;
      }
      .status {
        position: absolute;
        top: 30px;
        right: 30px;
        font-size: 12px;
        opacity: 0.7;
        padding: 4px 8px;
        background: #333;
        border-radius: 3px;
      }

      .axis-label {
        position: absolute;
        font-size: 10px;
        color: #888;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="controls">
        <button class="btn" data-range="hour">Hour</button>
        <button class="btn active" data-range="day">Day</button>
        <button class="btn" data-range="week">Week</button>
        <button class="btn" data-range="month">Month</button>
        <button class="btn" data-range="year">Year</button>
      </div>
    </div>
    <div class="main-content">
      <div class="chart-container">
        <canvas id="chart"></canvas>
        <div class="status" id="status">Connecting...</div>
      </div>
      <div class="sidebar">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
          "
        >
          <h3 style="margin: 0">Latest Readings</h3>
          <button
            id="admin-btn"
            class="btn"
            style="padding: 4px 8px; font-size: 10px"
          >
            Admin
          </button>
        </div>
        <div id="latest-readings"></div>
      </div>
    </div>

    <script>
      class RuuviChart {
          constructor() {
              this.canvas = document.getElementById('chart');
              this.ctx = this.canvas.getContext('2d');
              this.data = new Map();
              this.colors = ['#4a9eff', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
              this.range = 'day';
              this.bucketSize = 3600; // 1 hour in seconds default
              this.aggregated = false;
              this.ws = null;
              this.latestReadings = new Map();
              this.hoveredSensor = null;
              this.isAdmin = false;
              this.adminToken = null;
              this.sensorNames = new Map();

              // Performance optimization flags
              this.needsRender = false;
              this.isRendering = false;
              this.lastRenderTime = 0;
              this.renderThrottleMs = 16; // ~60fps

              // Debounced methods
              this.debouncedRender = this.debounce(() => this.performRender(), 100);
              this.throttledLatestUpdate = this.throttle((data) => this.performLatestUpdate(data), 250);

              this.setupWebSocket();
              this.setupControls();
              this.setupCanvas();
              this.scheduleRender();

              // ZERO POLLING: All updates are event-driven from server
              // Latest readings are pushed immediately when new data arrives
              this.connectionAttempts = 0;
              
              console.log('ðŸš€ ZERO POLLING CLIENT INITIALIZED');
              console.log('ðŸ“¡ Real-time updates: MQTT â†’ Server â†’ WebSocket â†’ Chart');
              console.log('ðŸš« No timers, no polling, pure event-driven architecture');

              // Optimized resize handler
              window.addEventListener('resize', this.debounce(() => {
                  this.setupCanvas();
                  this.scheduleRender();
              }, 250));
          }

          setupWebSocket() {
              const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
              this.ws = new WebSocket(`${protocol}//${location.host}`);
              this.connectionAttempts = (this.connectionAttempts || 0) + 1;

              this.ws.onopen = () => {
                  console.log('ðŸŸ¢ ZERO POLLING: WebSocket connected - pure event-driven updates');
                  document.getElementById('status').textContent = 'Connected';
                  this.connectionAttempts = 0;
                  
                  // Initial data load only - no periodic requests
                  this.ws.send(JSON.stringify({ type: 'getData', timeRange: this.range }));
                  this.ws.send(JSON.stringify({ type: 'getSensorNames' }));
                  // Note: Latest readings will be pushed automatically when data arrives
              };

              this.ws.onmessage = (event) => {
                  try {
                      const msg = JSON.parse(event.data);
                      this.handleServerMessage(msg);
                  } catch (error) {
                      console.error('Failed to parse WebSocket message:', error);
                  }
              };

              this.ws.onerror = (error) => {
                  console.error('WebSocket error:', error);
                  document.getElementById('status').textContent = 'Connection Error';
              };

              this.ws.onclose = (event) => {
                  console.log('ðŸ”´ WebSocket disconnected');
                  document.getElementById('status').textContent = 'Disconnected';
                  
                  // Smart reconnection with exponential backoff
                  const delay = Math.min(1000 * Math.pow(2, this.connectionAttempts), 30000);
                  console.log(`ðŸ”„ Reconnecting in ${delay}ms (attempt ${this.connectionAttempts})`);
                  setTimeout(() => this.setupWebSocket(), delay);
              };
          }

          handleServerMessage(msg) {
              // ZERO POLLING: Handle all server-driven messages
              switch (msg.type) {
                  case 'historicalData':
                      this.bucketSize = msg.bucketSize || 3600;
                      this.aggregated = msg.aggregated || false;
                      this.loadData(msg.data);
                      console.log(`ðŸ“Š Loaded ${msg.data.length} historical data points (${msg.timeRange})`);
                      break;
                      
                  case 'sensorData':
                      this.handleRealTimeUpdate(msg.data);
                      break;
                      
                  case 'latestReadings':
                      this.loadLatestReadings(msg.data);
                      console.log(`ðŸ“‹ Updated latest readings for ${msg.data.length} sensors`);
                      break;
                      
                  case 'bucketUpdate':
                      this.handleBucketUpdate(msg.data);
                      break;
                      
                  case 'adminAuthResult':
                      this.handleAdminAuthResult(msg);
                      break;
                      
                  case 'sensorNames':
                      this.loadSensorNames(msg.data);
                      break;
                      
                  case 'sensorNameSet':
                  case 'sensorNameDeleted':
                      this.renderLatestReadings();
                      break;
                      
                  default:
                      console.warn('Unknown message type:', msg.type);
              }
          }

          setupControls() {
              document.querySelectorAll('.btn[data-range]').forEach(btn => {
                  btn.addEventListener('click', () => {
                      const newRange = btn.dataset.range;
                      if (newRange === this.range) return; // No change needed
                      
                      document.querySelector('.btn.active')?.classList.remove('active');
                      btn.classList.add('active');
                      this.range = newRange;
                      
                      console.log(`ðŸ“… Time range changed to: ${this.range}`);
                      
                      if (this.ws?.readyState === WebSocket.OPEN) {
                          // ZERO POLLING: Only request data when range changes
                          this.ws.send(JSON.stringify({ type: 'getData', timeRange: this.range }));
                      }
                  });
              });

              // Setup admin button
              document.getElementById('admin-btn').addEventListener('click', () => {
                  if (this.isAdmin) {
                      this.logout();
                  } else {
                      this.promptAdminAuth();
                  }
              });
          }

          setupCanvas() {
              const rect = this.canvas.getBoundingClientRect();
              this.canvas.width = rect.width * devicePixelRatio;
              this.canvas.height = rect.height * devicePixelRatio;
              this.ctx.scale(devicePixelRatio, devicePixelRatio);
              this.canvas.style.width = rect.width + 'px';
              this.canvas.style.height = rect.height + 'px';
              
              // Add mouse leave event to reset highlighting when leaving the main content area
              const mainContent = document.querySelector('.main-content');
              if (mainContent && !mainContent.hasAttribute('data-mouse-events-setup')) {
                  mainContent.setAttribute('data-mouse-events-setup', 'true');
                  mainContent.addEventListener('mouseleave', () => {
                      if (this.hoveredSensor !== null) {
                          this.hoveredSensor = null;
                          this.scheduleRender();
                      }
                      
                      // Process any pending card updates when leaving the entire interface
                      if (this.pendingCardUpdates && this.pendingCardUpdates.size > 0) {
                          const pendingSensors = Array.from(this.pendingCardUpdates);
                          this.pendingCardUpdates.clear();
                          // Delay updates slightly to ensure smooth transition
                          setTimeout(() => {
                              pendingSensors.forEach(sensorMac => this.updateSensorCard(sensorMac));
                          }, 50);
                      }
                  });
                  
                  // Add touch events for mobile devices
                  mainContent.addEventListener('touchend', () => {
                      if (this.hoveredSensor !== null) {
                          this.hoveredSensor = null;
                          this.scheduleRender();
                      }
                  });
                  
                  mainContent.addEventListener('touchcancel', () => {
                      if (this.hoveredSensor !== null) {
                          this.hoveredSensor = null;
                          this.scheduleRender();
                      }
                  });
              }
          }

          loadData(rows) {
              this.data.clear();
              rows.forEach(row => {
                  // Normalize MAC address to lowercase
                  const normalizedMac = row.sensorMac.toLowerCase();
                  if (!this.data.has(normalizedMac)) {
                      this.data.set(normalizedMac, []);
                  }

                  if (this.aggregated) {
                      // Handle aggregated data
                      this.data.get(normalizedMac).push({
                          timestamp: row.timestamp,
                          temperature: row.avgTemperature,
                          minTemperature: row.minTemperature,
                          maxTemperature: row.maxTemperature,
                          humidity: row.avgHumidity,
                          minHumidity: row.minHumidity,
                          maxHumidity: row.maxHumidity,
                          dataPoints: row.dataPoints,
                          isAggregated: true
                      });
                  } else {
                      // Handle raw data
                      this.data.get(normalizedMac).push({
                          timestamp: row.timestamp,
                          temperature: row.temperature,
                          humidity: row.humidity,
                          isAggregated: false
                      });
                  }
              });
              this.scheduleRender();
          }

          handleRealTimeUpdate(data) {
              // ZERO POLLING: Handle real-time updates with fixed time window
              const normalizedMac = data.sensorMac.toLowerCase();
              const now = Math.floor(Date.now() / 1000);
              const timeWindow = this.getTimeWindow();
              const windowStart = now - timeWindow;

              console.log(`ðŸ“Š Real-time update: ${normalizedMac} ${data.temperature}Â°C (${this.range} view)`);

              // Only update chart if data point affects current time window
              if (data.timestamp >= windowStart) {
                  this.addRealTimeDataPoint(data);
                  this.scheduleRender();
              }

              // Always update latest reading for sidebar (regardless of time window)
              this.updateLatestReading(data);
          }

          addRealTimeDataPoint(data) {
              // Normalize MAC address to lowercase
              const normalizedMac = data.sensorMac.toLowerCase();
              if (!this.data.has(normalizedMac)) {
                  this.data.set(normalizedMac, []);
              }

              const sensorData = this.data.get(normalizedMac);
              const now = Math.floor(Date.now() / 1000);
              const timeWindow = this.getTimeWindow();

              if (this.aggregated && sensorData.length > 0) {
                  // Find the current bucket for real-time updates
                  const bucketStart = Math.floor(data.timestamp / this.bucketSize) * this.bucketSize;
                  const lastBucket = sensorData[sensorData.length - 1];

                  if (lastBucket && lastBucket.timestamp === bucketStart) {
                      // Update existing current bucket with running average
                      const totalPoints = lastBucket.dataPoints + 1;
                      lastBucket.temperature = ((lastBucket.temperature * lastBucket.dataPoints) + data.temperature) / totalPoints;
                      if (data.humidity !== null && lastBucket.humidity !== null) {
                          lastBucket.humidity = ((lastBucket.humidity * lastBucket.dataPoints) + data.humidity) / totalPoints;
                      }
                      lastBucket.dataPoints = totalPoints;
                      lastBucket.maxTemperature = Math.max(lastBucket.maxTemperature || data.temperature, data.temperature);
                      lastBucket.minTemperature = Math.min(lastBucket.minTemperature || data.temperature, data.temperature);
                  } else if (bucketStart >= lastBucket?.timestamp) {
                      // Only add new bucket if it's newer than the last one (edge of time window)
                      const newBucket = {
                          timestamp: bucketStart,
                          temperature: data.temperature,
                          minTemperature: data.temperature,
                          maxTemperature: data.temperature,
                          humidity: data.humidity,
                          minHumidity: data.humidity,
                          maxHumidity: data.humidity,
                          dataPoints: 1,
                          isAggregated: true
                      };
                      sensorData.push(newBucket);

                      // Keep only data within time window (maintain fixed window)
                      const cutoff = now - timeWindow;
                      while (sensorData.length > 0 && sensorData[0].timestamp < cutoff) {
                          sensorData.shift();
                      }
                  }
              } else {
                  // Raw data mode - only add if it's at the edge of our time window
                  const dataPoint = {
                      timestamp: data.timestamp,
                      temperature: data.temperature,
                      humidity: data.humidity === null ? null : data.humidity,
                      isAggregated: false
                  };
                  
                  // Insert at correct position (usually at the end for real-time data)
                  const insertIndex = sensorData.findIndex(p => p.timestamp > data.timestamp);
                  if (insertIndex === -1) {
                      sensorData.push(dataPoint);
                  } else {
                      sensorData.splice(insertIndex, 0, dataPoint);
                  }

                  // Maintain fixed time window
                  const cutoff = now - timeWindow;
                  while (sensorData.length > 0 && sensorData[0].timestamp < cutoff) {
                      sensorData.shift();
                  }
                  
                  // Limit total points to prevent memory bloat
                  const maxPoints = this.getMaxPointsForRange();
                  if (sensorData.length > maxPoints) {
                      sensorData.splice(0, sensorData.length - maxPoints);
                  }
              }
          }

          handleBucketUpdate(bucketData) {
              // ZERO POLLING: Handle bucket updates from server
              if (bucketData.timeRange !== this.range) {
                  return; // Ignore updates for different time ranges
              }

              const normalizedMac = bucketData.sensorMac.toLowerCase();
              console.log(`ðŸª£ Bucket update: ${normalizedMac} (${bucketData.timeRange}) bucket ${new Date(bucketData.timestamp * 1000).toLocaleTimeString()}`);
              
              if (!this.data.has(normalizedMac)) {
                  this.data.set(normalizedMac, []);
              }

              const sensorData = this.data.get(normalizedMac);
              const bucket = bucketData.bucketData;

              // Find and update the existing bucket or add new one
              const bucketIndex = sensorData.findIndex(p => p.timestamp === bucket.timestamp);
              
              const bucketPoint = {
                  timestamp: bucket.timestamp,
                  temperature: bucket.avgTemperature,
                  minTemperature: bucket.minTemperature,
                  maxTemperature: bucket.maxTemperature,
                  humidity: bucket.avgHumidity,
                  minHumidity: bucket.minHumidity,
                  maxHumidity: bucket.maxHumidity,
                  dataPoints: bucket.dataPoints,
                  isAggregated: true
              };
              
              if (bucketIndex !== -1) {
                  // Update existing bucket
                  sensorData[bucketIndex] = bucketPoint;
              } else {
                  // Add new bucket at correct position
                  const insertIndex = sensorData.findIndex(p => p.timestamp > bucket.timestamp);
                  if (insertIndex === -1) {
                      sensorData.push(bucketPoint);
                  } else {
                      sensorData.splice(insertIndex, 0, bucketPoint);
                  }
              }

              this.scheduleRender();
          }

          getMaxPointsForRange() {
              // Prevent memory bloat by limiting points per time range
              const limits = {
                  hour: 200,    // 5-min buckets = 12 per hour, raw data = ~200 points
                  day: 500,     // 1-hour buckets = 24 per day, raw data = ~500 points  
                  week: 300,    // 6-hour buckets = 28 per week
                  month: 200,   // 1-day buckets = ~30 per month
                  year: 400     // 30-day buckets = 12 per year
              };
              return limits[this.range] || 500;
          }



          getTimeWindow() {
              const ranges = { hour: 1, day: 24, week: 168, month: 720, year: 8760 };
              return ranges[this.range] * 60 * 60;
          }

          formatTimeLabel(timestamp, range) {
              const date = new Date(timestamp * 1000);

              switch(range) {
                  case 'hour':
                      return date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                  case 'day':
                      return date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                  case 'week':
                      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' +
                             date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit' });
                  case 'month':
                      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                  case 'year':
                      return date.toLocaleDateString('en-US', { month: 'short' });
                  default:
                      return date.toLocaleTimeString('en-US', { hour12: false });
              }
          }

          scheduleRender() {
              if (!this.needsRender) {
                  this.needsRender = true;
                  requestAnimationFrame(() => this.performRender());
              }
          }

          performRender() {
              if (!this.needsRender || this.isRendering) return;

              const now = performance.now();
              if (now - this.lastRenderTime < this.renderThrottleMs) {
                  requestAnimationFrame(() => this.performRender());
                  return;
              }

              this.isRendering = true;
              this.needsRender = false;
              this.lastRenderTime = now;

              try {
                  this.render();
              } catch (error) {
                  console.error('Render error:', error);
              } finally {
                  this.isRendering = false;
              }
          }

          render() {
              const rect = this.canvas.getBoundingClientRect();
              const width = rect.width;
              const height = rect.height;

              this.ctx.clearRect(0, 0, width, height);

              if (this.data.size === 0) {
                  return;
              }

              const now = Math.floor(Date.now() / 1000);
              const timeWindow = this.getTimeWindow();
              const startTime = now - timeWindow;

              // Calculate bounds with fixed temperature range (-20 to +40 minimum)
              let dataMinTemp = Infinity, dataMaxTemp = -Infinity;
              let minHum = Infinity, maxHum = -Infinity;
              let pointsInWindow = 0;

              this.data.forEach((points, sensorMac) => {
                  points.forEach(p => {
                      // For aggregated data, show all points; for raw data, filter by time window
                      if (this.aggregated || p.timestamp >= startTime) {
                          pointsInWindow++;
                          if (p.isAggregated) {
                              dataMinTemp = Math.min(dataMinTemp, p.minTemperature || p.temperature);
                              dataMaxTemp = Math.max(dataMaxTemp, p.maxTemperature || p.temperature);
                              if (p.minHumidity !== null && p.maxHumidity !== null) {
                                  minHum = Math.min(minHum, p.minHumidity);
                                  maxHum = Math.max(maxHum, p.maxHumidity);
                              }
                          } else {
                              dataMinTemp = Math.min(dataMinTemp, p.temperature);
                              dataMaxTemp = Math.max(dataMaxTemp, p.temperature);
                              if (p.humidity !== null && p.humidity !== undefined) {
                                  minHum = Math.min(minHum, p.humidity);
                                  maxHum = Math.max(maxHum, p.humidity);
                              }
                          }
                      }
                  });
              });

              // Set default temperature range (0 to +25) but expand if data exceeds
              const minTemp = Math.min(0, dataMinTemp !== Infinity ? dataMinTemp : 0);
              const maxTemp = Math.max(25, dataMaxTemp !== -Infinity ? dataMaxTemp : 25);

              // Fixed humidity range (0 to 100)
              if (minHum === Infinity) minHum = 0;
              if (maxHum === -Infinity) maxHum = 100;
              minHum = 0;
              maxHum = 100;

              if (pointsInWindow === 0) {
                  return;
              }

              const padding = 80;
              const chartWidth = width - padding * 2;
              const chartHeight = height - padding * 2;

              // Split chart area: temperature (top 2/3) and humidity (bottom 1/3)
              const tempChartHeight = Math.floor(chartHeight * 0.67);
              const humChartHeight = Math.floor(chartHeight * 0.33);
              const humChartTop = padding + tempChartHeight;
              
              // Calculate aligned zero positions for both axes
              const tempRange = maxTemp - minTemp;
              const tempZeroFromBottom = minTemp < 0 ? (-minTemp / tempRange) : 0;
              const tempZeroY = padding + tempChartHeight - (tempChartHeight * tempZeroFromBottom);
              
              // Align humidity zero with temperature zero
              const humZeroY = tempZeroY;

              // Draw axes
              this.ctx.strokeStyle = '#444';
              this.ctx.lineWidth = 1;
              this.ctx.beginPath();
              this.ctx.moveTo(padding, padding);
              this.ctx.lineTo(padding, height - padding);
              this.ctx.lineTo(width - padding, height - padding);
              this.ctx.stroke();

              // Draw time axis labels
              this.ctx.fillStyle = '#888';
              this.ctx.font = '10px sans-serif';
              const timeSteps = 6;

              // For aggregated data, use actual data range; for real-time, use time window
              let axisStartTime, axisEndTime;
              if (this.aggregated && this.data.size > 0) {
                  axisStartTime = this.getOldestTimestamp();
                  axisEndTime = this.getNewestTimestamp();
              } else {
                  axisStartTime = startTime;
                  axisEndTime = now;
              }

              for (let i = 0; i <= timeSteps; i++) {
                  const timeProgress = i / timeSteps;
                  const timestamp = axisStartTime + ((axisEndTime - axisStartTime) * timeProgress);
                  const x = padding + (chartWidth * timeProgress);
                  const label = this.formatTimeLabel(timestamp, this.range);

                  // Rotate text for better readability
                  this.ctx.save();
                  this.ctx.translate(x, height - padding + 15);
                  this.ctx.rotate(-Math.PI / 4);
                  this.ctx.fillText(label, 0, 0);
                  this.ctx.restore();

                  // Draw tick marks
                  this.ctx.strokeStyle = '#444';
                  this.ctx.beginPath();
                  this.ctx.moveTo(x, height - padding);
                  this.ctx.lineTo(x, height - padding + 5);
                  this.ctx.stroke();
              }

              // Draw temperature grid and labels (top 2/3)
              this.ctx.fillStyle = '#4a9eff';
              this.ctx.font = '10px sans-serif';

              for (let i = 0; i <= 5; i++) {
                  const temp = minTemp + (maxTemp - minTemp) * i / 5;
                  const y = padding + tempChartHeight - (tempChartHeight * i / 5);
                  this.ctx.fillText(`${temp.toFixed(1)}Â°C`, 5, y + 3);

                  // Draw horizontal grid lines for temperature
                  this.ctx.strokeStyle = temp === 0 ? '#666' : '#333'; // Emphasize zero line
                  this.ctx.setLineDash(temp === 0 ? [] : [2, 2]);
                  this.ctx.lineWidth = temp === 0 ? 2 : 1;
                  this.ctx.beginPath();
                  this.ctx.moveTo(padding, y);
                  this.ctx.lineTo(width - padding, y);
                  this.ctx.stroke();
                  this.ctx.setLineDash([]);
                  this.ctx.lineWidth = 1;
              }

              // Draw separator line between temperature and humidity
              this.ctx.strokeStyle = '#555';
              this.ctx.setLineDash([]);
              this.ctx.lineWidth = 1;
              this.ctx.beginPath();
              this.ctx.moveTo(padding, humChartTop);
              this.ctx.lineTo(width - padding, humChartTop);
              this.ctx.stroke();

              // Draw humidity grid and labels (bottom 1/3) - aligned with temperature zero
              if (minHum !== Infinity && maxHum !== -Infinity) {
                  this.ctx.fillStyle = '#ff6b6b';
                  this.ctx.globalAlpha = 0.6; // Reduced opacity for humidity
                  

                  // Calculate humidity positions to align 0% with temperature 0Â°C
                  for (let i = 0; i <= 4; i++) {
                      const hum = i * 25; // 0%, 25%, 50%, 75%, 100%
                      const humY = humZeroY - (hum / 100) * (humZeroY - humChartTop);
                      
                      if (humY >= humChartTop && humY <= humChartTop + humChartHeight) {
                          this.ctx.fillText(`${hum}%`, width - 40, humY + 3);

                          // Draw horizontal grid lines for humidity
                          this.ctx.strokeStyle = hum === 0 ? '#666' : '#333'; // Emphasize zero line
                          this.ctx.setLineDash(hum === 0 ? [] : [1, 3]);
                          this.ctx.lineWidth = hum === 0 ? 2 : 1;
                          this.ctx.beginPath();
                          this.ctx.moveTo(padding, humY);
                          this.ctx.lineTo(width - padding, humY);
                          this.ctx.stroke();
                          this.ctx.setLineDash([]);
                          this.ctx.lineWidth = 1;
                      }
                  }
                  this.ctx.globalAlpha = 1.0; // Reset opacity
              }

              // Draw temperature data in top area
              let colorIndex = 0;
              this.data.forEach((points, sensorMac) => {
                  const baseColor = this.colors[colorIndex % this.colors.length];
                  const isHovered = this.hoveredSensor === sensorMac;
                  const isOtherHovered = this.hoveredSensor && this.hoveredSensor !== sensorMac;

                  // Adjust color based on hover state
                  let color = baseColor;
                  let opacity = 1.0;
                  if (isOtherHovered) {
                      // Fade non-hovered sensors to gray
                      color = '#666';
                      opacity = 0.3;
                  } else if (isHovered) {
                      // Brighten hovered sensor
                      opacity = 1.0;
                  }

                  if (this.aggregated) {
                      // Draw min/max temperature band (filled area)
                      this.ctx.globalAlpha = isOtherHovered ? 0.1 : 0.3;
                      this.ctx.fillStyle = color;
                      
                      // Filter points with valid min/max temperature data and apply same timestamp filtering as main line
                      const validPoints = points.filter(p => 
                          (this.aggregated || p.timestamp >= startTime) &&
                          p.maxTemperature !== undefined && p.maxTemperature !== null &&
                          p.minTemperature !== undefined && p.minTemperature !== null &&
                          !isNaN(p.maxTemperature) && !isNaN(p.minTemperature) &&
                          p.isAggregated === true &&
                          p.maxTemperature >= p.minTemperature  // Ensure valid range (allow equal values)
                      );



                      if (validPoints.length > 1) {  // Need at least 2 points to create an area
                          this.ctx.beginPath();
                          let firstPoint = true;
                          
                          // Calculate coordinate variables once (same as main temperature line)
                          const dataStart = this.aggregated ? this.getOldestTimestamp() : null;
                          const dataSpan = this.aggregated ? this.getNewestTimestamp() - dataStart : null;

                          // Top edge (max values)
                          validPoints.forEach(p => {
                              let x;
                              if (this.aggregated) {
                                  x = padding + ((p.timestamp - dataStart) / Math.max(dataSpan, 3600)) * chartWidth;
                              } else {
                                  x = padding + ((p.timestamp - startTime) / timeWindow) * chartWidth;
                              }
                              const y = padding + tempChartHeight - ((p.maxTemperature - minTemp) / (maxTemp - minTemp)) * tempChartHeight;
                              if (firstPoint) {
                                  this.ctx.moveTo(x, y);
                                  firstPoint = false;
                              } else {
                                  this.ctx.lineTo(x, y);
                              }
                          });

                          // Bottom edge (min values, reversed)
                          const reversedPoints = [...validPoints].reverse();
                          reversedPoints.forEach(p => {
                              let x;
                              if (this.aggregated) {
                                  x = padding + ((p.timestamp - dataStart) / Math.max(dataSpan, 3600)) * chartWidth;
                              } else {
                                  x = padding + ((p.timestamp - startTime) / timeWindow) * chartWidth;
                              }
                              const y = padding + tempChartHeight - ((p.minTemperature - minTemp) / (maxTemp - minTemp)) * tempChartHeight;
                              this.ctx.lineTo(x, y);
                          });

                          this.ctx.closePath();
                          this.ctx.fill();
                      }
                      this.ctx.globalAlpha = 1.0;
                  }

                  // Add glow effect for hovered sensor
                  if (isHovered) {
                      this.ctx.shadowColor = color;
                      this.ctx.shadowBlur = 8;
                      this.ctx.shadowOffsetX = 0;
                      this.ctx.shadowOffsetY = 0;
                  }

                  // Draw prominent average temperature line
                  this.ctx.strokeStyle = color;
                  this.ctx.lineWidth = isHovered ? 4 : 3; // Thicker line for hovered sensor
                  this.ctx.globalAlpha = opacity;
                  this.ctx.beginPath();
                  let first = true;

                  points.forEach(p => {
                      if (this.aggregated || p.timestamp >= startTime) {
                          let x;
                          if (this.aggregated) {
                              const dataStart = this.getOldestTimestamp();
                              const dataSpan = this.getNewestTimestamp() - dataStart;
                              x = padding + ((p.timestamp - dataStart) / Math.max(dataSpan, 3600)) * chartWidth;
                          } else {
                              x = padding + ((p.timestamp - startTime) / timeWindow) * chartWidth;
                          }
                          const y = padding + tempChartHeight - ((p.temperature - minTemp) / (maxTemp - minTemp)) * tempChartHeight;
                          if (first) {
                              this.ctx.moveTo(x, y);
                              first = false;
                          } else {
                              this.ctx.lineTo(x, y);
                          }
                      }
                  });
                  this.ctx.stroke();

                  // Reset shadow for other elements
                  if (isHovered) {
                      this.ctx.shadowBlur = 0;
                  }

                  // Draw humidity in bottom area with same color but reduced opacity
                  if (minHum !== Infinity && maxHum !== -Infinity) {
                      // Add subtle glow for humidity on hovered sensor
                      if (isHovered) {
                          this.ctx.shadowColor = color;
                          this.ctx.shadowBlur = 4;
                      }

                      this.ctx.globalAlpha = isOtherHovered ? 0.1 : 0.3; // Reduced opacity for humidity
                      this.ctx.strokeStyle = color; // Same color as temperature
                      this.ctx.lineWidth = isHovered ? 3 : 2;
                      this.ctx.setLineDash([3, 3]); // Dashed line to distinguish from temperature
                      this.ctx.beginPath();
                      first = true;

                      points.forEach(p => {
                          const humidity = p.humidity;
                          if ((this.aggregated || p.timestamp >= startTime) && humidity !== null && humidity !== undefined) {
                              let x;
                              if (this.aggregated) {
                                  const dataStart = this.getOldestTimestamp();
                                  const dataSpan = this.getNewestTimestamp() - dataStart;
                                  x = padding + ((p.timestamp - dataStart) / Math.max(dataSpan, 3600)) * chartWidth;
                              } else {
                                  x = padding + ((p.timestamp - startTime) / timeWindow) * chartWidth;
                              }
                              const y = humZeroY - (humidity / 100) * (humZeroY - humChartTop);
                              if (first) {
                                  this.ctx.moveTo(x, y);
                                  first = false;
                              } else {
                                  this.ctx.lineTo(x, y);
                              }
                          }
                      });
                      this.ctx.stroke();
                      this.ctx.setLineDash([]);

                      // Reset shadow and opacity
                      if (isHovered) {
                          this.ctx.shadowBlur = 0;
                      }
                      this.ctx.globalAlpha = 1.0; // Reset opacity
                  }

                  colorIndex++;
              });
          }

          getOldestTimestamp() {
              let oldest = Infinity;
              this.data.forEach(points => {
                  points.forEach(p => {
                      oldest = Math.min(oldest, p.timestamp);
                  });
              });
              return oldest;
          }

          getDataTimeSpan() {
              let oldest = Infinity, newest = -Infinity;
              this.data.forEach(points => {
                  points.forEach(p => {
                      oldest = Math.min(oldest, p.timestamp);
                      newest = Math.max(newest, p.timestamp);
                  });
              });
              return Math.max(newest - oldest, this.bucketSize); // Minimum bucket size span
          }

          getNewestTimestamp() {
              let newest = -Infinity;
              this.data.forEach(points => {
                  points.forEach(p => {
                      newest = Math.max(newest, p.timestamp);
                  });
              });
              return newest !== -Infinity ? newest : Math.floor(Date.now() / 1000);
          }

          loadLatestReadings(readings) {
              this.latestReadings.clear();
              readings.forEach(reading => {
                  this.latestReadings.set(reading.sensorMac.toLowerCase(), reading);
              });
              this.renderLatestReadings();
          }

          loadSensorNames(names) {
              this.sensorNames.clear();
              names.forEach(item => {
                  this.sensorNames.set(item.sensorMac.toLowerCase(), item.customName);
              });
              this.renderLatestReadings();
          }

          promptAdminAuth() {
              const password = prompt('Enter admin password:');
              if (password) {
                  this.ws.send(JSON.stringify({
                      type: 'adminAuth',
                      password: password
                  }));
              }
          }

          handleAdminAuthResult(msg) {
              if (msg.success) {
                  this.isAdmin = true;
                  this.adminToken = msg.token;
                  document.getElementById('admin-btn').textContent = 'Logout';
                  document.getElementById('admin-btn').style.background = '#ff6b6b';
                  this.renderLatestReadings();
              } else {
                  alert(msg.message || 'Authentication failed');
              }
          }

          logout() {
              this.isAdmin = false;
              this.adminToken = null;
              document.getElementById('admin-btn').textContent = 'Admin';
              document.getElementById('admin-btn').style.background = '#333';
              this.renderLatestReadings();
          }

          editSensorName(sensorMac) {
              const currentName = this.sensorNames.get(sensorMac) || sensorMac.slice(-8).toUpperCase();
              const newName = prompt(`Enter name for sensor ${sensorMac.slice(-8).toUpperCase()}:`, currentName);

              if (newName && newName.trim() !== currentName) {
                  this.ws.send(JSON.stringify({
                      type: 'setSensorName',
                      sensorMac: sensorMac,
                      customName: newName.trim(),
                      adminToken: this.adminToken
                  }));
              }
          }

          updateLatestReading(data) {
              this.throttledLatestUpdate(data);
          }

          performLatestUpdate(data) {
              const normalizedMac = data.sensorMac.toLowerCase();
              const now = Math.floor(Date.now() / 1000);
              this.latestReadings.set(normalizedMac, {
                  sensorMac: normalizedMac,
                  temperature: data.temperature,
                  humidity: data.humidity,
                  timestamp: data.timestamp,
                  secondsAgo: now - data.timestamp
              });
              this.updateSensorCard(normalizedMac);
          }

          updateSensorCard(sensorMac) {
              const container = document.getElementById('latest-readings');
              const reading = this.latestReadings.get(sensorMac);
              if (!reading) return;

              // Find existing card or determine insertion point
              let existingCard = container.querySelector(`[data-sensor-mac="${sensorMac}"]`);
              
              // Avoid updating cards that are currently being hovered to prevent twitching
              if (existingCard && (existingCard.matches(':hover') || this.hoveredSensor === sensorMac)) {
                  // Schedule update for later when hover ends
                  if (!this.pendingCardUpdates) this.pendingCardUpdates = new Set();
                  this.pendingCardUpdates.add(sensorMac);
                  return;
              }

              const now = Math.floor(Date.now() / 1000);
              const secondsAgo = reading.secondsAgo !== undefined ? reading.secondsAgo : (now - reading.timestamp);
              const isOffline = secondsAgo > 300; // 5 minutes

              // Get color and display info
              const sortedReadings = Array.from(this.latestReadings.values())
                  .sort((a, b) => a.sensorMac.localeCompare(b.sensorMac));
              const sensorIndex = sortedReadings.findIndex(r => r.sensorMac === sensorMac);
              const sensorColor = this.colors[sensorIndex % this.colors.length];
              const customName = this.sensorNames.get(sensorMac);
              const displayName = customName || sensorMac.slice(-8).toUpperCase();
              const ageText = this.formatAge(secondsAgo);

              if (existingCard) {
                  // Check if significant data has changed to avoid unnecessary updates
                  const currentTemp = existingCard.querySelector('.sensor-temp')?.textContent;
                  const newTemp = `${reading.temperature.toFixed(1)}Â°C`;
                  const currentAge = existingCard.querySelector('.sensor-age')?.textContent;
                  
                  // Only update if temperature changed by more than 0.1Â°C or age changed significantly
                  if (currentTemp === newTemp && currentAge === ageText) {
                      return; // No meaningful change, skip update
                  }

                  // Update existing card content without rebuilding
                  existingCard.className = `sensor-item ${isOffline ? 'sensor-offline' : ''}`;
                  existingCard.style.borderLeftColor = sensorColor;
                  
                  // Update temperature
                  const tempElement = existingCard.querySelector('.sensor-temp');
                  if (tempElement) tempElement.textContent = newTemp;
                  
                  // Update humidity
                  const humidityElement = existingCard.querySelector('.sensor-humidity');
                  if (reading.humidity !== null) {
                      if (humidityElement) {
                          humidityElement.textContent = `${reading.humidity.toFixed(1)}%`;
                      } else {
                          // Add humidity element if it didn't exist
                          const sensorLeft = existingCard.querySelector('.sensor-left');
                          const humidityDiv = document.createElement('div');
                          humidityDiv.className = 'sensor-humidity';
                          humidityDiv.textContent = `${reading.humidity.toFixed(1)}%`;
                          sensorLeft.appendChild(humidityDiv);
                      }
                  } else if (humidityElement) {
                      // Remove humidity element if no humidity data
                      humidityElement.remove();
                  }
                  
                  // Update age
                  const ageElement = existingCard.querySelector('.sensor-age');
                  if (ageElement) ageElement.textContent = ageText;
                  
                  // Update name if admin state might have changed
                  const nameElement = existingCard.querySelector('.sensor-mac');
                  if (nameElement) {
                      nameElement.textContent = displayName;
                      if (this.isAdmin) {
                          nameElement.style.cursor = 'pointer';
                          nameElement.style.textDecoration = 'underline';
                      } else {
                          nameElement.style.cursor = '';
                          nameElement.style.textDecoration = '';
                      }
                  }
              } else {
                  // Create new card (full rebuild only for this sensor)
                  this.renderLatestReadings();
              }
          }

          renderLatestReadings() {
              const container = document.getElementById('latest-readings');
              container.innerHTML = '';

              if (this.latestReadings.size === 0) {
                  container.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No sensor data</div>';
                  return;
              }

              const now = Math.floor(Date.now() / 1000);
              const sortedReadings = Array.from(this.latestReadings.values())
                  .sort((a, b) => a.sensorMac.localeCompare(b.sensorMac));

              sortedReadings.forEach((reading, index) => {
                  const secondsAgo = reading.secondsAgo !== undefined ? reading.secondsAgo : (now - reading.timestamp);
                  const isOffline = secondsAgo > 300; // 5 minutes
                  const sensorColor = this.colors[index % this.colors.length];
                  const customName = this.sensorNames.get(reading.sensorMac);
                  const displayName = customName || reading.sensorMac.slice(-8).toUpperCase();

                  const item = document.createElement('div');
                  item.className = `sensor-item ${isOffline ? 'sensor-offline' : ''}`;
                  item.style.borderLeftColor = sensorColor;
                  item.setAttribute('data-sensor-mac', reading.sensorMac);

                  const ageText = this.formatAge(secondsAgo);

                  item.innerHTML = `
                      <div class="sensor-left">
                          <div class="sensor-mac" ${this.isAdmin ? 'style="cursor: pointer; text-decoration: underline;"' : ''}>${displayName}</div>
                          <div class="sensor-temp">${reading.temperature.toFixed(1)}Â°C</div>
                          ${reading.humidity !== null ? `<div class="sensor-humidity">${reading.humidity.toFixed(1)}%</div>` : ''}
                      </div>
                      <div class="sensor-age">${ageText}</div>
                  `;

                  // Add hover event listeners for graph highlighting
                  item.addEventListener('mouseenter', () => {
                      this.hoveredSensor = reading.sensorMac;
                      this.scheduleRender();
                  });

                  item.addEventListener('mouseleave', () => {
                      this.hoveredSensor = null;
                      this.scheduleRender();
                      
                      // Process any pending card updates for this sensor
                      if (this.pendingCardUpdates && this.pendingCardUpdates.has(reading.sensorMac)) {
                          this.pendingCardUpdates.delete(reading.sensorMac);
                          // Delay the update slightly to ensure smooth transition
                          setTimeout(() => this.updateSensorCard(reading.sensorMac), 50);
                      }
                  });

                  // Add touch event listeners for mobile devices
                  item.addEventListener('touchstart', () => {
                      this.hoveredSensor = reading.sensorMac;
                      this.scheduleRender();
                  });

                  // Add click handler for admin name editing
                  if (this.isAdmin) {
                      const macElement = item.querySelector('.sensor-mac');
                      macElement.addEventListener('click', (e) => {
                          e.stopPropagation();
                          this.editSensorName(reading.sensorMac);
                      });
                  }

                  container.appendChild(item);
              });
          }

          formatAge(seconds) {
              // Handle negative values (clock drift, future timestamps)
              if (seconds <= 0) return 'now';
              
              // Round to nearest second for display
              seconds = Math.round(seconds);
              
              if (seconds < 60) return `${seconds}s ago`;
              if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
              if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
              return `${Math.floor(seconds / 86400)}d ago`;
          }

          debounce(func, wait) {
              let timeout;
              return function executedFunction(...args) {
                  const later = () => {
                      clearTimeout(timeout);
                      func(...args);
                  };
                  clearTimeout(timeout);
                  timeout = setTimeout(later, wait);
              };
          }

          throttle(func, limit) {
              let inThrottle;
              return function(...args) {
                  if (!inThrottle) {
                      func.apply(this, args);
                      inThrottle = true;
                      setTimeout(() => inThrottle = false, limit);
                  }
              };
          }
      }

      // PWA Service Worker
      if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('/sw.js').catch(console.error);
      }

      // Initialize app
      new RuuviChart();
    </script>
  </body>
</html>
