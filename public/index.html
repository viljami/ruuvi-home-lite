<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#1a1a1a" />
    <title>Ruuvi Home</title>
    <link rel="manifest" href="manifest.json" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
    <link rel="apple-touch-icon" href="favicon.svg" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #1a1a1a;
        color: #e0e0e0;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        overflow: hidden;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }
      .header {
        padding: 10px 20px;
        border-bottom: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #222;
        z-index: 1;
      }
      .controls {
        display: flex;
        gap: 10px;
      }
      .btn {
        background: #333;
        border: 1px solid #555;
        color: #e0e0e0;
        padding: 5px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }
      .btn.active {
        background: #4a9eff;
        border-color: #4a9eff;
      }
      .main-content {
        flex: 1;
        display: flex;
      }
      .chart-container {
        flex: 1;
        position: relative;
        padding: 20px;
      }
      .sidebar {
        width: 280px;
        background: #2a2a2a;
        border-left: 1px solid #444;
        padding: 15px;
        overflow-y: auto;
      }
      #chart {
        width: 100%;
        height: 100%;
        display: block;
      }
      .sidebar h3 {
        margin: 0 0 10px 0;
        color: #e0e0e0;
        font-size: 16px;
      }
      .sensor-item {
        background: #333;
        margin-bottom: 6px;
        padding: 8px 10px;
        border-radius: 4px;
        border-left: 3px solid #4a9eff;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .sensor-item:hover {
        background: #404040;
        transform: translateX(2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
      .sensor-left {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .sensor-mac {
        font-family: monospace;
        color: #888;
        font-size: 11px;
      }
      .sensor-temp {
        font-weight: bold;
        color: #4a9eff;
      }
      .sensor-humidity {
        color: #ff6b6b;
      }
      .sensor-age {
        color: #666;
        font-size: 10px;
      }
      .sensor-offline {
        border-left-color: #666;
        opacity: 0.6;
      }
      .sensor-offline .sensor-temp {
        color: #666;
      }
      .status {
        position: absolute;
        top: 30px;
        right: 30px;
        font-size: 12px;
        opacity: 0.7;
        padding: 4px 8px;
        background: #333;
        border-radius: 3px;
      }

      .axis-label {
        position: absolute;
        font-size: 10px;
        color: #888;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="controls">
        <button class="btn" data-range="hour">Hour</button>
        <button class="btn active" data-range="day">Day</button>
        <button class="btn" data-range="week">Week</button>
        <button class="btn" data-range="month">Month</button>
        <button class="btn" data-range="year">Year</button>
      </div>
    </div>
    <div class="main-content">
      <div class="chart-container">
        <canvas id="chart"></canvas>
        <div class="status" id="status">Connecting...</div>
      </div>
      <div class="sidebar">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
          "
        >
          <h3 style="margin: 0">Latest Readings</h3>
          <button
            id="admin-btn"
            class="btn"
            style="padding: 4px 8px; font-size: 10px"
          >
            Admin
          </button>
        </div>
        <div id="latest-readings"></div>
      </div>
    </div>

    <script>
      class TimeFormatter {
        static formatTimeLabel(timestamp, range) {
          const date = new Date(timestamp * 1000);

          switch (range) {
            case "hour":
              return date.toLocaleTimeString("en-US", {
                hour12: false,
                hour: "2-digit",
                minute: "2-digit",
              });
            case "day":
              return date.toLocaleTimeString("en-US", {
                hour12: false,
                hour: "2-digit",
                minute: "2-digit",
              });
            case "week":
              return (
                date.toLocaleDateString("en-US", {
                  month: "short",
                  day: "numeric",
                }) +
                " " +
                date.toLocaleTimeString("en-US", {
                  hour12: false,
                  hour: "2-digit",
                })
              );
            case "month":
              return date.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
              });
            case "year":
              return date.toLocaleDateString("en-US", { month: "short" });
            default:
              return date.toLocaleTimeString("en-US", { hour12: false });
          }
        }
      }

      class Utils {
        static debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        }

        static throttle(func, limit) {
          let inThrottle;
          return function (...args) {
            if (!inThrottle) {
              func.apply(this, args);
              inThrottle = true;
              setTimeout(() => (inThrottle = false), limit);
            }
          };
        }
      }

      class ChartComponent {
        constructor(canvas, ctx, config) {
          this.canvas = canvas;
          this.ctx = ctx;
          this.config = {
            type: "temperature", // 'temperature' or 'humidity'
            area: { x: 0, y: 0, width: 100, height: 100 }, // Area within canvas
            scale: { min: 0, max: 100 },
            color: "#4a9eff",
            opacity: 1.0,
            lineWidth: 3,
            lineStyle: "solid", // 'solid' or 'dashed'
            unit: "Â°C",
            gridLines: 5,
            showGrid: true,
            showLabels: true,
            ...config,
          };
        }

        calculateCoordinates(value, timestamp, startTime, timeWindow) {
          const { area, scale } = this.config;

          // X coordinate (time)
          const x =
            area.x + ((timestamp - startTime) / timeWindow) * area.width;

          // Y coordinate (value) - inverted so higher values are at top
          const y =
            area.y +
            area.height -
            ((value - scale.min) / (scale.max - scale.min)) * area.height;

          return { x, y };
        }

        drawGrid() {
          if (!this.config.showGrid) return;

          const { area, scale, gridLines } = this.config;

          this.ctx.strokeStyle = "#333";
          this.ctx.setLineDash([2, 2]);
          this.ctx.lineWidth = 1;
          this.ctx.globalAlpha = 0.5;

          // Draw horizontal grid lines
          for (let i = 0; i <= gridLines; i++) {
            const value = scale.min + ((scale.max - scale.min) * i) / gridLines;
            const y = area.y + area.height - (area.height * i) / gridLines;

            // Emphasize zero line
            if (Math.abs(value) < 0.01) {
              this.ctx.strokeStyle = "#666";
              this.ctx.setLineDash([]);
              this.ctx.lineWidth = 2;
            } else {
              this.ctx.strokeStyle = "#333";
              this.ctx.setLineDash([2, 2]);
              this.ctx.lineWidth = 1;
            }

            this.ctx.beginPath();
            this.ctx.moveTo(area.x, y);
            this.ctx.lineTo(area.x + area.width, y);
            this.ctx.stroke();
          }

          this.ctx.setLineDash([]);
          this.ctx.globalAlpha = 1.0;
        }

        drawLabels() {
          if (!this.config.showLabels) return;

          const { area, scale, gridLines, unit, color } = this.config;
          const canvasWidth = this.canvas.width;

          this.ctx.fillStyle = color;
          this.ctx.font = "10px sans-serif";
          this.ctx.globalAlpha = 1.0;

          for (let i = 0; i <= gridLines; i++) {
            const value = scale.min + ((scale.max - scale.min) * i) / gridLines;
            const y = area.y + area.height - (area.height * i) / gridLines;

            const labelX =
              this.config.type === "temperature" ? 5 : canvasWidth - 50;
            this.ctx.fillText(`${value.toFixed(1)}${unit}`, labelX, y + 3);
          }

          this.ctx.globalAlpha = 1.0;
        }

        drawData(
          dataPoints,
          startTime,
          timeWindow,
          isHovered = false,
          isOtherHovered = false,
        ) {
          if (!dataPoints || dataPoints.length === 0) return;

          const { color, opacity, lineWidth, lineStyle } = this.config;

          // Adjust appearance based on hover state
          let drawColor = color;
          let drawOpacity = opacity;

          if (isOtherHovered) {
            drawColor = "#666";
            drawOpacity = 0.3;
          } else if (isHovered) {
            drawOpacity = 1.0;
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = 8;
          }

          this.ctx.strokeStyle = drawColor;
          this.ctx.lineWidth = isHovered ? lineWidth + 1 : lineWidth;
          this.ctx.globalAlpha = drawOpacity;

          if (lineStyle === "dashed") {
            this.ctx.setLineDash([3, 3]);
          }

          this.ctx.beginPath();
          let first = true;

          dataPoints.forEach((point) => {
            const value =
              this.config.type === "temperature"
                ? point.temperature
                : point.humidity;
            if (value !== null && value !== undefined) {
              const coords = this.calculateCoordinates(
                value,
                point.timestamp,
                startTime,
                timeWindow,
              );

              if (first) {
                this.ctx.moveTo(coords.x, coords.y);
                first = false;
              } else {
                this.ctx.lineTo(coords.x, coords.y);
              }
            }
          });

          this.ctx.stroke();
          this.ctx.setLineDash([]);
          this.ctx.shadowBlur = 0;
          this.ctx.globalAlpha = 1.0;
        }

        render(dataPoints, startTime, timeWindow, isHovered, isOtherHovered) {
          this.drawGrid();
          this.drawLabels();
          this.drawData(
            dataPoints,
            startTime,
            timeWindow,
            isHovered,
            isOtherHovered,
          );
        }
      }

      class SensorCard {
        constructor(
          reading,
          sensorIndex,
          colors,
          sensorNames,
          isAdmin,
          onHover,
          onEditName,
        ) {
          this.reading = reading;
          this.sensorIndex = sensorIndex;
          this.colors = colors;
          this.sensorNames = sensorNames;
          this.isAdmin = isAdmin;
          this.onHover = onHover;
          this.onEditName = onEditName;
          this.element = null;
          this.pendingUpdate = false;
        }

        get sensorColor() {
          return this.colors[this.sensorIndex % this.colors.length];
        }

        get displayName() {
          const customName = this.sensorNames.get(this.reading.sensorMac);
          return customName || this.reading.sensorMac.slice(-8).toUpperCase();
        }

        get isOffline() {
          const now = Math.floor(Date.now() / 1000);
          const secondsAgo =
            this.reading.secondsAgo !== undefined
              ? this.reading.secondsAgo
              : now - this.reading.timestamp;
          return secondsAgo > 300; // 5 minutes
        }

        formatAge(seconds) {
          if (seconds <= 0) return "now";
          seconds = Math.round(seconds);

          if (seconds < 60) return `${seconds}s ago`;
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
          return `${Math.floor(seconds / 86400)}d ago`;
        }

        createElement() {
          const now = Math.floor(Date.now() / 1000);
          const secondsAgo =
            this.reading.secondsAgo !== undefined
              ? this.reading.secondsAgo
              : now - this.reading.timestamp;

          const item = document.createElement("div");
          item.className = `sensor-item ${this.isOffline ? "sensor-offline" : ""}`;
          item.style.borderLeftColor = this.sensorColor;
          item.setAttribute("data-sensor-mac", this.reading.sensorMac);

          const ageText = this.formatAge(secondsAgo);

          item.innerHTML = `
                  <div class="sensor-left">
                      <div class="sensor-mac" ${this.isAdmin ? 'style="cursor: pointer; text-decoration: underline;"' : ""}>${this.displayName}</div>
                      <div class="sensor-temp">${this.reading.temperature.toFixed(1)}Â°C</div>
                      ${this.reading.humidity !== null ? `<div class="sensor-humidity">${this.reading.humidity.toFixed(1)}%</div>` : ""}
                  </div>
                  <div class="sensor-age">${ageText}</div>
              `;

          this.setupEventListeners(item);
          this.element = item;
          return item;
        }

        setupEventListeners(element) {
          // Hover events for graph highlighting
          element.addEventListener("mouseenter", () => {
            this.onHover(this.reading.sensorMac);
          });

          element.addEventListener("mouseleave", () => {
            this.onHover(null);

            // Process pending update if any
            if (this.pendingUpdate) {
              this.pendingUpdate = false;
              setTimeout(() => this.update(), 50);
            }
          });

          // Touch events for mobile
          element.addEventListener("touchstart", () => {
            this.onHover(this.reading.sensorMac);
          });

          // Admin click handler for name editing
          if (this.isAdmin) {
            const macElement = element.querySelector(".sensor-mac");
            macElement.addEventListener("click", (e) => {
              e.stopPropagation();
              this.onEditName(this.reading.sensorMac);
            });
          }
        }

        update(newReading, newSensorIndex, newIsAdmin) {
          if (!this.element) return;

          // If card is being hovered, schedule update for later
          if (this.element.matches(":hover")) {
            this.pendingUpdate = true;
            return;
          }

          const oldReading = this.reading;
          this.reading = newReading || this.reading;
          this.sensorIndex =
            newSensorIndex !== undefined ? newSensorIndex : this.sensorIndex;
          this.isAdmin = newIsAdmin !== undefined ? newIsAdmin : this.isAdmin;

          const now = Math.floor(Date.now() / 1000);
          const secondsAgo =
            this.reading.secondsAgo !== undefined
              ? this.reading.secondsAgo
              : now - this.reading.timestamp;

          // Check if significant data has changed
          const currentTemp =
            this.element.querySelector(".sensor-temp")?.textContent;
          const newTemp = `${this.reading.temperature.toFixed(1)}Â°C`;
          const currentAge =
            this.element.querySelector(".sensor-age")?.textContent;
          const newAge = this.formatAge(secondsAgo);

          // Only update if there are meaningful changes
          if (
            currentTemp === newTemp &&
            currentAge === newAge &&
            this.isOffline === secondsAgo > 300
          ) {
            return;
          }

          // Update element class and style
          this.element.className = `sensor-item ${this.isOffline ? "sensor-offline" : ""}`;
          this.element.style.borderLeftColor = this.sensorColor;

          // Update temperature
          const tempElement = this.element.querySelector(".sensor-temp");
          if (tempElement) tempElement.textContent = newTemp;

          // Update humidity
          const humidityElement =
            this.element.querySelector(".sensor-humidity");
          if (this.reading.humidity !== null) {
            if (humidityElement) {
              humidityElement.textContent = `${this.reading.humidity.toFixed(1)}%`;
            } else {
              const sensorLeft = this.element.querySelector(".sensor-left");
              const humidityDiv = document.createElement("div");
              humidityDiv.className = "sensor-humidity";
              humidityDiv.textContent = `${this.reading.humidity.toFixed(1)}%`;
              sensorLeft.appendChild(humidityDiv);
            }
          } else if (humidityElement) {
            humidityElement.remove();
          }

          // Update age
          const ageElement = this.element.querySelector(".sensor-age");
          if (ageElement) ageElement.textContent = newAge;

          // Update name display
          const nameElement = this.element.querySelector(".sensor-mac");
          if (nameElement) {
            nameElement.textContent = this.displayName;
            if (this.isAdmin) {
              nameElement.style.cursor = "pointer";
              nameElement.style.textDecoration = "underline";
            } else {
              nameElement.style.cursor = "";
              nameElement.style.textDecoration = "";
            }
          }
        }

        destroy() {
          if (this.element) {
            this.element.remove();
            this.element = null;
          }
        }
      }

      class WebSocketManager {
        constructor(onMessage, onStatusChange) {
          this.onMessage = onMessage;
          this.onStatusChange = onStatusChange;
          this.ws = null;
          this.connectionAttempts = 0;
          this.reconnectTimeout = null;
          this.maxReconnectAttempts = 10;
          this.reconnectDelay = 1000;
        }

        connect() {
          const protocol = location.protocol === "https:" ? "wss:" : "ws:";
          this.ws = new WebSocket(`${protocol}//${location.host}`);
          this.connectionAttempts++;

          this.ws.onopen = () => {
            console.log(
              "ðŸŸ¢ ZERO POLLING: WebSocket connected - pure event-driven updates",
            );
            this.connectionAttempts = 0;
            this.onStatusChange("Connected");

            // Send initial requests
            this.send({ type: "getData", timeRange: "day" });
            this.send({ type: "getSensorNames" });
          };

          this.ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              this.onMessage(message);
            } catch (error) {
              console.error("WebSocket message parse error:", error);
            }
          };

          this.ws.onclose = () => {
            console.log("ðŸ”´ WebSocket disconnected");
            this.onStatusChange("Disconnected");
            this.scheduleReconnect();
          };

          this.ws.onerror = (error) => {
            console.error("WebSocket error:", error);
            this.onStatusChange("Connection Error");
          };
        }

        scheduleReconnect() {
          if (this.connectionAttempts < this.maxReconnectAttempts) {
            const delay = Math.min(
              1000 * Math.pow(2, this.connectionAttempts),
              30000,
            );
            this.onStatusChange(
              `Reconnecting... (${this.connectionAttempts}/${this.maxReconnectAttempts})`,
            );
            this.reconnectTimeout = setTimeout(() => {
              this.connect();
            }, delay);
          } else {
            this.onStatusChange("Connection failed");
          }
        }

        send(message) {
          if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(message));
          }
        }

        disconnect() {
          if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
          }
          if (this.ws) {
            this.ws.close();
          }
        }
      }

      class DataManager {
        constructor() {
          this.data = new Map();
          this.latestReadings = new Map();
          this.sensorNames = new Map();
          this.bucketSize = 3600;
          this.aggregated = false;
          this.range = "day";
        }

        loadData(data) {
          this.data.clear();
          data.forEach((point) => {
            const normalizedMac = point.sensorMac.toLowerCase();
            if (!this.data.has(normalizedMac)) {
              this.data.set(normalizedMac, []);
            }
            this.data.get(normalizedMac).push({
              timestamp: point.timestamp,
              temperature: point.avgTemperature || point.temperature,
              humidity: point.avgHumidity || point.humidity,
              minTemperature: point.minTemperature,
              maxTemperature: point.maxTemperature,
              minHumidity: point.minHumidity,
              maxHumidity: point.maxHumidity,
              count: point.count,
              isAggregated: point.isAggregated || false,
            });
          });
        }

        addRealTimeDataPoint(data) {
          const normalizedMac = data.sensorMac.toLowerCase();
          const now = Math.floor(Date.now() / 1000);
          const timeWindow = this.getTimeWindow();

          if (!this.data.has(normalizedMac)) {
            this.data.set(normalizedMac, []);
          }

          const sensorData = this.data.get(normalizedMac);
          const dataPoint = {
            timestamp: data.timestamp,
            temperature: data.temperature,
            humidity: data.humidity,
            isAggregated: false,
          };

          const insertIndex = sensorData.findIndex(
            (p) => p.timestamp > data.timestamp,
          );
          if (insertIndex === -1) {
            sensorData.push(dataPoint);
          } else {
            sensorData.splice(insertIndex, 0, dataPoint);
          }

          // Maintain time window
          const cutoff = now - timeWindow;
          while (sensorData.length > 0 && sensorData[0].timestamp < cutoff) {
            sensorData.shift();
          }

          // Limit points
          const maxPoints = this.getMaxPointsForRange();
          if (sensorData.length > maxPoints) {
            sensorData.splice(0, sensorData.length - maxPoints);
          }
        }

        handleBucketUpdate(bucketData) {
          bucketData.forEach((bucket) => {
            const normalizedMac = bucket.sensorMac.toLowerCase();

            if (!this.data.has(normalizedMac)) {
              this.data.set(normalizedMac, []);
            }

            const sensorData = this.data.get(normalizedMac);
            const bucketPoint = {
              timestamp: bucket.timestamp,
              temperature: bucket.avgTemperature,
              humidity: bucket.avgHumidity,
              minTemperature: bucket.minTemperature,
              maxTemperature: bucket.maxTemperature,
              minHumidity: bucket.minHumidity,
              maxHumidity: bucket.maxHumidity,
              count: bucket.count,
              isAggregated: true,
            };

            const existingIndex = sensorData.findIndex(
              (p) => p.timestamp === bucket.timestamp && p.isAggregated,
            );
            if (existingIndex >= 0) {
              sensorData[existingIndex] = bucketPoint;
            } else {
              const insertIndex = sensorData.findIndex(
                (p) => p.timestamp > bucket.timestamp,
              );
              if (insertIndex === -1) {
                sensorData.push(bucketPoint);
              } else {
                sensorData.splice(insertIndex, 0, bucketPoint);
              }
            }
          });
        }

        updateLatestReading(data) {
          const normalizedMac = data.sensorMac.toLowerCase();
          const now = Math.floor(Date.now() / 1000);
          this.latestReadings.set(normalizedMac, {
            sensorMac: normalizedMac,
            temperature: data.temperature,
            humidity: data.humidity,
            timestamp: data.timestamp,
            secondsAgo: now - data.timestamp,
          });
        }

        getTimeWindow() {
          const windows = {
            hour: 3600,
            day: 86400,
            week: 604800,
            month: 2592000,
            year: 31536000,
          };
          return windows[this.range] || 86400;
        }

        getMaxPointsForRange() {
          const maxPoints = {
            hour: 3600,
            day: 1440,
            week: 2016,
            month: 8760,
            year: 8760,
          };
          return maxPoints[this.range] || 1440;
        }

        setSensorName(sensorMac, name) {
          this.sensorNames.set(sensorMac, name);
        }

        loadSensorNames(names) {
          this.sensorNames.clear();
          Object.entries(names).forEach(([mac, name]) => {
            this.sensorNames.set(mac.toLowerCase(), name);
          });
        }

        setRange(range) {
          this.range = range;
        }

        clearData() {
          this.data.clear();
          this.latestReadings.clear();
        }
      }

      class AdminManager {
        constructor(wsManager, onStateChange) {
          this.wsManager = wsManager;
          this.onStateChange = onStateChange;
          this.isAdmin = false;
          this.adminToken = null;
        }

        promptAuth() {
          const password = prompt("Enter admin password:");
          if (password) {
            this.wsManager.send({
              type: "adminAuth",
              password: password,
            });
          }
        }

        handleAuthResult(msg) {
          if (msg.success) {
            this.isAdmin = true;
            this.adminToken = msg.token;
            this.updateUI();
            this.onStateChange(true);
          } else {
            alert(msg.message || "Authentication failed");
          }
        }

        logout() {
          this.isAdmin = false;
          this.adminToken = null;
          this.updateUI();
          this.onStateChange(false);
        }

        editSensorName(sensorMac, currentName) {
          const displayName = currentName || sensorMac.slice(-8).toUpperCase();
          const newName = prompt(
            `Enter name for sensor ${sensorMac.slice(-8).toUpperCase()}:`,
            displayName,
          );

          if (newName && newName.trim() !== displayName) {
            this.wsManager.send({
              type: "setSensorName",
              sensorMac: sensorMac,
              customName: newName.trim(),
              adminToken: this.adminToken,
            });
          }
        }

        updateUI() {
          const adminBtn = document.getElementById("admin-btn");
          if (this.isAdmin) {
            adminBtn.textContent = "Logout";
            adminBtn.style.background = "#ff6b6b";
          } else {
            adminBtn.textContent = "Admin";
            adminBtn.style.background = "#333";
          }
        }

        setupAdminButton() {
          const adminBtn = document.getElementById("admin-btn");
          adminBtn.addEventListener("click", () => {
            if (this.isAdmin) {
              this.logout();
            } else {
              this.promptAuth();
            }
          });
        }
      }

      class TimeRangeController {
        constructor(dataManager, wsManager, onRangeChange) {
          this.dataManager = dataManager;
          this.wsManager = wsManager;
          this.onRangeChange = onRangeChange;
        }

        setupControls() {
          document.querySelectorAll(".btn[data-range]").forEach((btn) => {
            btn.addEventListener("click", () => {
              const newRange = btn.dataset.range;
              if (newRange === this.dataManager.range) return;

              document.querySelector(".btn.active")?.classList.remove("active");
              btn.classList.add("active");
              this.dataManager.setRange(newRange);

              console.log(
                `ðŸ“… Time range changed to: ${this.dataManager.range}`,
              );

              this.wsManager.send({
                type: "getData",
                timeRange: this.dataManager.range,
              });
              this.onRangeChange(newRange);
            });
          });
        }
      }

      class ChartRenderer {
        constructor(canvas, ctx, dataManager, colors) {
          this.canvas = canvas;
          this.ctx = ctx;
          this.dataManager = dataManager;
          this.colors = colors;
          this.temperatureChart = null;
          this.humidityChart = null;
          this.hoveredSensor = null;
        }

        setHoveredSensor(sensorMac) {
          this.hoveredSensor = sensorMac;
        }

        render() {
          const rect = this.canvas.getBoundingClientRect();
          const width = rect.width;
          const height = rect.height;

          this.ctx.clearRect(0, 0, width, height);

          if (this.dataManager.data.size === 0) {
            return;
          }

          const now = Math.floor(Date.now() / 1000);
          const timeWindow = this.dataManager.getTimeWindow();
          const startTime = now - timeWindow;

          // Calculate data bounds
          let dataMinTemp = Infinity,
            dataMaxTemp = -Infinity;
          let minHum = Infinity,
            maxHum = -Infinity;
          let pointsInWindow = 0;

          this.dataManager.data.forEach((points, sensorMac) => {
            points.forEach((p) => {
              if (this.dataManager.aggregated || p.timestamp >= startTime) {
                pointsInWindow++;
                if (p.isAggregated) {
                  dataMinTemp = Math.min(
                    dataMinTemp,
                    p.minTemperature || p.temperature,
                  );
                  dataMaxTemp = Math.max(
                    dataMaxTemp,
                    p.maxTemperature || p.temperature,
                  );
                  if (p.minHumidity !== null && p.maxHumidity !== null) {
                    minHum = Math.min(minHum, p.minHumidity);
                    maxHum = Math.max(maxHum, p.maxHumidity);
                  }
                } else {
                  dataMinTemp = Math.min(dataMinTemp, p.temperature);
                  dataMaxTemp = Math.max(dataMaxTemp, p.temperature);
                  if (p.humidity !== null && p.humidity !== undefined) {
                    minHum = Math.min(minHum, p.humidity);
                    maxHum = Math.max(maxHum, p.humidity);
                  }
                }
              }
            });
          });

          if (pointsInWindow === 0) {
            return;
          }

          // Set temperature range (expandable from 0-25Â°C default)
          const minTemp = Math.min(
            0,
            dataMinTemp !== Infinity ? dataMinTemp : 0,
          );
          const maxTemp = Math.max(
            25,
            dataMaxTemp !== -Infinity ? dataMaxTemp : 25,
          );

          // Fixed humidity range
          const humMin = 0;
          const humMax = 100;

          const padding = 80;
          const chartWidth = width - padding * 2;
          const chartHeight = height - padding * 2;

          // Split chart area: temperature (top 60%) and humidity (bottom 40%)
          const tempChartHeight = Math.floor(chartHeight * 0.6);
          const humChartHeight = Math.floor(chartHeight * 0.4);
          const humChartTop = padding + tempChartHeight;

          // Initialize or update chart components
          this.initializeChartComponents(
            padding,
            chartWidth,
            tempChartHeight,
            humChartHeight,
            humChartTop,
            minTemp,
            maxTemp,
            humMin,
            humMax,
          );

          // Draw main axes and grid
          this.drawAxesAndGrid(
            width,
            height,
            padding,
            chartWidth,
            humChartTop,
            startTime,
            timeWindow,
          );

          // Render chart data
          this.renderChartData(startTime, timeWindow);
        }

        initializeChartComponents(
          padding,
          chartWidth,
          tempChartHeight,
          humChartHeight,
          humChartTop,
          minTemp,
          maxTemp,
          humMin,
          humMax,
        ) {
          const tempArea = {
            x: padding,
            y: padding,
            width: chartWidth,
            height: tempChartHeight,
          };
          const humArea = {
            x: padding,
            y: humChartTop,
            width: chartWidth,
            height: humChartHeight,
          };

          if (!this.temperatureChart) {
            this.temperatureChart = new ChartComponent(this.canvas, this.ctx, {
              type: "temperature",
              area: tempArea,
              scale: { min: minTemp, max: maxTemp },
              color: "#4a9eff",
              opacity: 1.0,
              lineWidth: 3,
              lineStyle: "solid",
              unit: "Â°C",
              gridLines: 5,
              showGrid: true,
              showLabels: true,
            });
          } else {
            this.temperatureChart.config.scale = { min: minTemp, max: maxTemp };
            this.temperatureChart.config.area = tempArea;
          }

          if (!this.humidityChart) {
            this.humidityChart = new ChartComponent(this.canvas, this.ctx, {
              type: "humidity",
              area: humArea,
              scale: { min: humMin, max: humMax },
              color: "#ff6b6b",
              opacity: 0.9,
              lineWidth: 3,
              lineStyle: "dashed",
              unit: "%",
              gridLines: 4,
              showGrid: true,
              showLabels: true,
            });
          } else {
            this.humidityChart.config.scale = { min: humMin, max: humMax };
            this.humidityChart.config.area = humArea;
          }
        }

        drawAxesAndGrid(
          width,
          height,
          padding,
          chartWidth,
          humChartTop,
          startTime,
          timeWindow,
        ) {
          // Draw main axes
          this.ctx.strokeStyle = "#444";
          this.ctx.lineWidth = 1;
          this.ctx.beginPath();
          this.ctx.moveTo(padding, padding);
          this.ctx.lineTo(padding, height - padding);
          this.ctx.lineTo(width - padding, height - padding);
          this.ctx.stroke();

          // Draw separator line between temperature and humidity
          this.ctx.strokeStyle = "#555";
          this.ctx.beginPath();
          this.ctx.moveTo(padding, humChartTop);
          this.ctx.lineTo(width - padding, humChartTop);
          this.ctx.stroke();

          // Draw time axis labels
          this.drawTimeAxisLabels(
            width,
            height,
            padding,
            chartWidth,
            startTime,
            timeWindow,
          );
        }

        drawTimeAxisLabels(
          width,
          height,
          padding,
          chartWidth,
          startTime,
          timeWindow,
        ) {
          this.ctx.fillStyle = "#888";
          this.ctx.font = "10px sans-serif";
          const timeSteps = 6;

          for (let i = 0; i <= timeSteps; i++) {
            const timeProgress = i / timeSteps;
            const timestamp = startTime + timeWindow * timeProgress;
            const x = padding + chartWidth * timeProgress;
            const label = TimeFormatter.formatTimeLabel(
              timestamp,
              this.dataManager.range,
            );

            this.ctx.save();
            this.ctx.translate(x, height - padding + 15);
            this.ctx.rotate(-Math.PI / 4);
            this.ctx.fillText(label, 0, 0);
            this.ctx.restore();

            // Draw tick marks
            this.ctx.strokeStyle = "#444";
            this.ctx.beginPath();
            this.ctx.moveTo(x, height - padding);
            this.ctx.lineTo(x, height - padding + 5);
            this.ctx.stroke();
          }
        }

        renderChartData(startTime, timeWindow) {
          // Prepare chart data
          const preparedData = new Map();
          this.dataManager.data.forEach((points, sensorMac) => {
            const filteredPoints = points.filter(
              (p) => p.timestamp >= startTime,
            );
            if (filteredPoints.length > 0) {
              preparedData.set(sensorMac, filteredPoints);
            }
          });

          // Render each sensor's data using both chart components
          let colorIndex = 0;
          preparedData.forEach((points, sensorMac) => {
            const baseColor = this.colors[colorIndex % this.colors.length];
            const isHovered = this.hoveredSensor === sensorMac;
            const isOtherHovered =
              this.hoveredSensor && this.hoveredSensor !== sensorMac;

            // Update colors for this sensor
            this.temperatureChart.config.color = baseColor;
            this.humidityChart.config.color = baseColor;

            // Render temperature chart
            this.temperatureChart.render(
              points,
              startTime,
              timeWindow,
              isHovered,
              isOtherHovered,
            );

            // Render humidity chart
            this.humidityChart.render(
              points,
              startTime,
              timeWindow,
              isHovered,
              isOtherHovered,
            );

            colorIndex++;
          });
        }
      }

      class RuuviChart {
        constructor() {
          this.canvas = document.getElementById("chart");
          this.ctx = this.canvas.getContext("2d");
          this.colors = [
            "#4a9eff",
            "#ff6b6b",
            "#4ecdc4",
            "#45b7d1",
            "#96ceb4",
            "#ffeaa7",
          ];
          this.hoveredSensor = null;
          this.sensorCards = new Map();

          // Initialize component managers
          this.dataManager = new DataManager();
          this.wsManager = new WebSocketManager(
            (message) => this.handleServerMessage(message),
            (status) => this.updateConnectionStatus(status),
          );
          this.adminManager = new AdminManager(this.wsManager, (isAdmin) =>
            this.renderLatestReadings(),
          );
          this.timeRangeController = new TimeRangeController(
            this.dataManager,
            this.wsManager,
            () => this.scheduleRender(),
          );
          this.chartRenderer = new ChartRenderer(
            this.canvas,
            this.ctx,
            this.dataManager,
            this.colors,
          );

          // Performance optimization flags
          this.needsRender = false;
          this.isRendering = false;
          this.lastRenderTime = 0;
          this.renderThrottleMs = 16; // ~60fps

          // Debounced methods
          this.debouncedRender = Utils.debounce(
            () => this.performRender(),
            100,
          );
          this.throttledLatestUpdate = Utils.throttle(
            (data) => this.performLatestUpdate(data),
            250,
          );

          this.wsManager.connect();
          this.setupControls();
          this.setupCanvas();
          this.scheduleRender();

          // ZERO POLLING: All updates are event-driven from server
          // Latest readings are pushed immediately when new data arrives

          console.log("ðŸš€ ZERO POLLING CLIENT INITIALIZED");
          console.log(
            "ðŸ“¡ Real-time updates: MQTT â†’ Server â†’ WebSocket â†’ Chart",
          );
          console.log(
            "ðŸš« No timers, no polling, pure event-driven architecture",
          );

          // Optimized resize handler
          window.addEventListener(
            "resize",
            Utils.debounce(() => {
              this.setupCanvas();
              this.scheduleRender();
            }, 250),
          );
        }

        updateConnectionStatus(status) {
          document.getElementById("status").textContent = status;
        }

        handleServerMessage(msg) {
          // ZERO POLLING: Handle all server-driven messages
          switch (msg.type) {
            case "historicalData":
              this.dataManager.bucketSize = msg.bucketSize || 3600;
              this.dataManager.aggregated = msg.aggregated || false;
              this.dataManager.loadData(msg.data);
              this.scheduleRender();
              console.log(
                `ðŸ“Š Loaded ${msg.data.length} historical data points (${msg.timeRange})`,
              );
              break;

            case "sensorData":
              this.dataManager.addRealTimeDataPoint(msg.data);
              this.dataManager.updateLatestReading(msg.data);
              this.updateSensorCard(msg.data.sensorMac.toLowerCase());
              this.scheduleRender();
              break;

            case "latestReadings":
              Object.entries(msg.data).forEach(([mac, reading]) => {
                this.dataManager.updateLatestReading({
                  sensorMac: mac,
                  temperature: reading.temperature,
                  humidity: reading.humidity,
                  timestamp: reading.timestamp,
                });
                this.updateSensorCard(mac.toLowerCase());
              });
              console.log(
                `ðŸ“± Loaded ${Object.keys(msg.data).length} latest readings`,
              );
              break;

            case "bucketUpdate":
              this.dataManager.handleBucketUpdate(msg.data);
              this.scheduleRender();
              break;

            case "adminAuthResult":
              this.adminManager.handleAuthResult(msg);
              break;

            case "sensorNames":
              this.dataManager.loadSensorNames(msg.data);
              this.renderLatestReadings();
              break;

            default:
              console.log("Unknown message type:", msg.type);
          }
        }

        setupControls() {
          this.timeRangeController.setupControls();
          this.adminManager.setupAdminButton();
        }

        clearHoverState() {
          if (this.hoveredSensor !== null) {
            this.hoveredSensor = null;
            this.chartRenderer.setHoveredSensor(null);
            this.scheduleRender();
          }
        }

        setupCanvas() {
          const rect = this.canvas.getBoundingClientRect();
          this.canvas.width = rect.width * devicePixelRatio;
          this.canvas.height = rect.height * devicePixelRatio;
          this.ctx.scale(devicePixelRatio, devicePixelRatio);
          this.canvas.style.width = rect.width + "px";
          this.canvas.style.height = rect.height + "px";

          // Add mouse leave event to reset highlighting when leaving the main content area
          const mainContent = document.querySelector(".main-content");
          if (
            mainContent &&
            !mainContent.hasAttribute("data-mouse-events-setup")
          ) {
            mainContent.setAttribute("data-mouse-events-setup", "true");
            mainContent.addEventListener("mouseleave", () => {
              this.clearHoverState();
            });

            // Add touch events for mobile devices
            mainContent.addEventListener("touchend", () => {
              this.clearHoverState();
            });

            mainContent.addEventListener("touchcancel", () => {
              this.clearHoverState();
            });
          }
        }

        scheduleRender() {
          if (!this.needsRender) {
            this.needsRender = true;
            requestAnimationFrame(() => this.performRender());
          }
        }

        performRender() {
          if (!this.needsRender || this.isRendering) return;

          const now = performance.now();
          if (now - this.lastRenderTime < this.renderThrottleMs) {
            requestAnimationFrame(() => this.performRender());
            return;
          }

          this.isRendering = true;
          this.needsRender = false;
          this.lastRenderTime = now;

          try {
            this.render();
          } catch (error) {
            console.error("Render error:", error);
          } finally {
            this.isRendering = false;
          }
        }

        render() {
          this.chartRenderer.setHoveredSensor(this.hoveredSensor);
          this.chartRenderer.render();
        }

        getOldestTimestamp() {
          let oldest = Infinity;
          this.data.forEach((points) => {
            points.forEach((p) => {
              oldest = Math.min(oldest, p.timestamp);
            });
          });
          return oldest;
        }

        getDataTimeSpan() {
          let oldest = Infinity,
            newest = -Infinity;
          this.data.forEach((points) => {
            points.forEach((p) => {
              oldest = Math.min(oldest, p.timestamp);
              newest = Math.max(newest, p.timestamp);
            });
          });
          return Math.max(newest - oldest, this.bucketSize); // Minimum bucket size span
        }

        getNewestTimestamp() {
          let newest = -Infinity;
          this.dataManager.data.forEach((points) => {
            points.forEach((p) => {
              newest = Math.max(newest, p.timestamp);
            });
          });
          return newest !== -Infinity ? newest : Math.floor(Date.now() / 1000);
        }

        updateSensorCard(sensorMac) {
          const reading = this.dataManager.latestReadings.get(sensorMac);
          if (!reading) return;

          const sortedReadings = Array.from(
            this.dataManager.latestReadings.values(),
          ).sort((a, b) => a.sensorMac.localeCompare(b.sensorMac));
          const sensorIndex = sortedReadings.findIndex(
            (r) => r.sensorMac === sensorMac,
          );

          const existingCard = this.sensorCards.get(sensorMac);
          if (existingCard) {
            existingCard.update(reading, sensorIndex, this.isAdmin);
          } else {
            this.renderLatestReadings();
          }
        }

        renderLatestReadings() {
          const container = document.getElementById("latest-readings");

          // Clear existing cards
          this.sensorCards.forEach((card) => card.destroy());
          this.sensorCards.clear();
          container.innerHTML = "";

          if (this.dataManager.latestReadings.size === 0) {
            container.innerHTML =
              '<div style="color: #666; text-align: center; padding: 20px;">No sensor data</div>';
            return;
          }

          const sortedReadings = Array.from(
            this.dataManager.latestReadings.values(),
          ).sort((a, b) => a.sensorMac.localeCompare(b.sensorMac));

          sortedReadings.forEach((reading, index) => {
            const sensorCard = new SensorCard(
              reading,
              index,
              this.colors,
              this.dataManager.sensorNames,
              this.adminManager.isAdmin,
              (sensorMac) => {
                this.hoveredSensor = sensorMac;
                this.chartRenderer.setHoveredSensor(sensorMac);
                this.scheduleRender();
              },
              (sensorMac) => {
                const currentName = this.dataManager.sensorNames.get(sensorMac);
                this.adminManager.editSensorName(sensorMac, currentName);
              },
            );

            const cardElement = sensorCard.createElement();
            this.sensorCards.set(reading.sensorMac, sensorCard);
            container.appendChild(cardElement);
          });
        }
      }

      // PWA Service Worker
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("/sw.js").catch(console.error);
      }

      // Initialize app
      new RuuviChart();
    </script>
  </body>
</html>
